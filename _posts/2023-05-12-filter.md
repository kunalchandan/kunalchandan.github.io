---
title: Filter
date: 2023-05-12 10:00:00
categories: [projects]
tags: [personal-projects]
author: kchandan
math: true
---

# Problem Statement

## Passive Filter Design Project
This project is meant to be a collaboration, leading you through your thought process and ability to navigate this project.
Our goal with this exercise is to define, architect and implement a design generator for a large number of passive filters realizable on a userâ€™s PCB.
The filter(s) can be instantiated into user code via a function call similar to voltage-divider. The filter is instantiated as a jitx module with a fixed
input/output nomenclature and using parts lookup. This is language agnostic, please choose any language of choice!
### Filter Types
For this exercise, we would like eventually support of the following filter options:
- RC filters
- Nth order
- Low pass, band pass, high pass
- Spice sim verification
- LC filters
- Order from 1 to 7
- Low pass, band pass, high pass
- Bessel, Butterworth, Chebyshev, Elliptic etc
- Global options
- Frequency specs
- Realizable components (availability)
- Optimize for area or cost
- Allow user to input preferences for component values
- Allow user to indicate BOM consolidation priority
### Initial Starting Point
To begin the exercise, we can try the following:
- Start with just RC filters
- LPF filter type
- Three stage filter
- Circuit diagram
- Frequency response to component values calculation
- How should we incorporate circuit and board-level non-idealities (parasitics)?
Collateral
Website with a nice calculator: https://rf-tools.com/lc-filter/


# Basic RC Filter
```python
from lcapy import *

netlist = """
R1 V_{i+} 2; right
C1 2 3; down
W 3 3; down=0, ground
W V_{i-} 3; right
W 2 V_{o+}; right
W 3 V_{o-}; right
"""
print(netlist)
cct = Circuit(netlist)

cct.draw('1st_order_rc.png', color='white')
```


![1st order RC filter](/assets/img/filter/1st_order_rc.png)

The resulting transfer function from $V_{i}$ to $V_{o+}$

```python
tf = cct.Voc('V_{i+}',  'V_{o+}').laplace()
```

$$
\frac{1}{s + \frac{1}{C_{1} R_{1}}}
$$

And we can substitute values for the capacitor and resistor with the following:

```python
tf = tf.subs({
        'C1': 4,
        'R1': 5,
        })

tf.ZPK()
```

$$
1 \cdot \frac{1}{s + \frac{1}{20}}
$$

The resulting bode plot looks like.

![1st order RC filter bode ](/assets/img/filter/1st_order_bode.png)

We can clearly see that the $-3dB$ point is at the pole $0.05$


But you see all the analysis above was completely wrong. Since the transfer function obtained is completely wrong as we can see from the bode plot. The response has gain greater than unity which is an obvious red flag.

The response should look like:

![1st order RC filter](/assets/img/filter/1st_order_rc_new.png)

![1st order RC filter bode](/assets/img/filter/1st_order_bode_correct.png)

The transfer function looks like:

$$
\frac{\frac{1}{C_{0}} \cdot \frac{1}{R_{0}}}{s + \frac{1}{C_{0} R_{0}}}
$$

And substituting 1 for all values results in:

$$
1 \cdot \frac{1}{s + 1}
$$

However since we want to be able to generate a filter for some particular frequency, we must ensure that the poles are placed at the particular frequency.

To do this we can take the original transfer function and pull out the poles and solve for values that satisfy the target frequency.

<!-- $$
\displaystyle \left[ \left( - \frac{1}{10 R_{1}}, \  R_{1}\right)\right]
$$ -->

Since the pole of an RC LPF filter is given by
$$
\frac{\frac{1}{C_{0}} \cdot \frac{1}{R_{0}}}{s + \frac{1}{C_{0} R_{0}}}
$$
Then the pole is given by:
$$
s + \frac{1}{C_{0} R_{0}} = 0
$$

$$
j\omega = -\frac{1}{C_{0} R_{0}}
$$

And we can now select for some values of the capacitor and resistor based on the target frequency $\omega = 2 \pi f$. Thus, we can use trial and error to solve for the closest values of R and C that match that for the frequency.


# Nth Order RC Filter

```python
netlist = """
W 0 V_{i-}; right=0.4
"""
cct = Circuit(netlist)
# cct.add('V V_{i+} V_{i-} step 1; down')
cct.add('P1 V_{i+} V_{i-}; down, v_=v_i(t)')
for stage in range(N_STAGES):
    ground_end_node = f'G_{stage}'
    if stage == 0:
        ground_start_node = 'V_{i-}'
        start_node = 'V_{i+}'
        next_node = stage + 1
    else:
        ground_start_node = f'G_{stage-1}'
        start_node = stage
        next_node = stage + 1

    cct.add(f'R_{stage} {start_node} {next_node}; right')
    cct.add(f'C_{stage} {next_node} {ground_end_node}; down')
    cct.add(f'W {ground_start_node} {ground_end_node}; right')

vop = 'V_{o+}'
vom = 'V_{o-}'
cct.add(f'W {next_node} {vop}; right')
cct.add(f'W {ground_end_node} {vom}; right')
cct.add(f'P2 {vop} {vom}; down, v^=v_o(t)')

print()
print('Finalized netlist')
print(cct.netlist())

cct.draw(label_nodes='all', color='white')
cct.draw('3rd_order_rc_new.png', color='white')
```

For a 3 stage filter, that looks like:

```
Finalized netlist
W 0 V_{i-}; right=0.4
P1 V_{i+} V_{i-}; down, v_=v_i(t)
R_0 V_{i+} 1; right
C_0 1 G_0; down
W V_{i-} G_0; right
R_1 1 2; right
C_1 2 G_1; down
W G_0 G_1; right
R_2 2 3; right
C_2 3 G_2; down
W G_1 G_2; right
W 3 V_{o+}; right
W G_2 V_{o-}; right
P2 V_{o+} V_{o-}; down, v^=v_o(t)
```

![3rd order](/assets/img/filter/3rd_order_rc_new.png)

The transfer function.

$$
\frac{\frac{1}{C_{0}} \cdot \frac{1}{C_{1}} \cdot \frac{1}{C_{2}} \cdot \frac{1}{R_{0}} \cdot \frac{1}{R_{1}} \cdot \frac{1}{R_{2}}}{s^{3} + \frac{s^{2} \left(C_{0} C_{1} R_{0} R_{1} + C_{0} C_{2} R_{0} R_{1} + C_{0} C_{2} R_{0} R_{2} + C_{1} C_{2} R_{0} R_{2} + C_{1} C_{2} R_{1} R_{2}\right)}{C_{0} C_{1} C_{2} R_{0} R_{1} R_{2}} + \frac{s \left(C_{0} R_{0} + C_{1} R_{0} + C_{1} R_{1} + C_{2} R_{0} + C_{2} R_{1} + C_{2} R_{2}\right)}{C_{0} C_{1} C_{2} R_{0} R_{1} R_{2}} + \frac{1}{C_{0} C_{1} C_{2} R_{0} R_{1} R_{2}}}

$$

```python
# Sub all resistor and capacitor values for 1
Hs = tf.subs({f'C_{i}' : 1 for i in range(N_STAGES)}).subs({f'R_{i}' : 1 for i in range(N_STAGES)}).ZPK()
Hs.latex()
```

$$
1 \cdot \frac{1}{s + \frac{5}{3} + \frac{7}{3 \sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}} + \frac{\sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}}{3}} \cdot \frac{1}{s + \frac{5}{3} + \frac{7}{3 \left(- \frac{1}{2} + \frac{\sqrt{3} \mathrm{j}}{2}\right) \sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}} + \frac{\left(- \frac{1}{2} + \frac{\sqrt{3} \mathrm{j}}{2}\right) \sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}}{3}} \cdot \frac{1}{s + \frac{5}{3} + \frac{\left(- \frac{1}{2} - \frac{\sqrt{3} \mathrm{j}}{2}\right) \sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}}{3} + \frac{7}{3 \left(- \frac{1}{2} - \frac{\sqrt{3} \mathrm{j}}{2}\right) \sqrt[3]{\frac{7}{2} + \frac{21 \sqrt{3} \mathrm{j}}{2}}}}
$$


